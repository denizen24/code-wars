### Задача: Проверка на наличие дубликатов в массиве

Описание задачи:
Дан массив целых чисел. Необходимо определить, содержит ли массив дубликаты.

Пример:
```
Input: nums = [1, 2, 3, 1]
Output: true

Input: nums = [1, 2, 3, 4]
Output: false
```

### Решение

Существует несколько способов решить эту задачу. Рассмотрим два подхода: один с использованием хэш-таблицы и другой с использованием сортировки.

#### 1. Подход с использованием хэш-таблицы

Этот подход включает в себя использование Set для хранения уникальных значений. Если мы встречаем число, которое уже находится в Set, это означает, что в массиве есть дубликаты.
```js
function containsDuplicate(nums) {
const seen = new Set(); // Создаем пустой Set для хранения уникальных значений

    for (let num of nums) {
        if (seen.has(num)) {
            return true; // Если число уже в Set, значит, есть дубликат
        }
        seen.add(num); // Добавляем число в Set
    }

    return false; // Если дубликатов нет
}

// Пример использования
console.log(containsDuplicate([1, 2, 3, 1])); // Вывод: true
console.log(containsDuplicate([1, 2, 3, 4])); // Вывод: false
```

Сложность:
- Временная сложность: O(n) — проходим по массиву один раз.
- Пространственная сложность: O(n) — в худшем случае храним все элементы в Set.

#### 2. Подход с использованием сортировки

Этот подход включает в себя сортировку массива и проверку соседних элементов на равенство.
```js
function containsDuplicate(nums) {
nums.sort((a, b) => a - b); // Сортируем массив

    for (let i = 0; i < nums.length - 1; i++) {
        if (nums[i] === nums[i + 1]) {
            return true; // Если соседние элементы равны, значит, есть дубликат
        }
    }

    return false; // Если дубликатов нет
}

// Пример использования
console.log(containsDuplicate([1, 2, 3, 1])); // Вывод: true
console.log(containsDuplicate([1, 2, 3, 4])); // Вывод: false
```

Сложность:
- Временная сложность: O(n log n) — из-за сортировки.
- Пространственная сложность: O(1) — если сортируем на месте, или O(n) — если используем дополнительное пространство.


#### 3. Использование Set для проверки дубликатов 2

Когда вы помещаете все элементы массива в Set, он автоматически удаляет дубликаты, так как Set хранит только уникальные значения. Затем вы можете просто сравнить длину исходного массива и длину Set. Если длины разные, значит, в массиве есть дубликаты.

### Пример реализации

Вот как можно реализовать этот подход:
```js
function containsDuplicate(nums) {
const uniqueValues = new Set(nums); // Создаем Set из массива

    return uniqueValues.size !== nums.length; // Сравниваем длины
}

// Пример использования
console.log(containsDuplicate([1, 2, 3, 1])); // Вывод: true
console.log(containsDuplicate([1, 2, 3, 4])); // Вывод: false

```
### Объяснение кода:

1. Создание Set:
    - `const uniqueValues = new Set(nums);` — создаем новый Set, передавая в него массив nums. В результате Set будет содержать только уникальные значения из массива.

2. Сравнение длины:
    - `return uniqueValues.size !== nums.length;` — проверяем, отличается ли длина Set от длины исходного массива. Если длины разные, значит, в массиве есть дубликаты, и функция вернет true. В противном случае — false.

### Сложность

- Временная сложность: `O(n)` — мы проходим по массиву один раз, чтобы создать Set.
- Пространственная сложность: `O(n)` — в худшем случае храним все элементы в Set.

### Заключение

Использование Set для проверки наличия дубликатов в массиве является простым и эффективным решением. Этот подход хорошо иллюстрирует, как можно использовать структуры данных для упрощения задач.

