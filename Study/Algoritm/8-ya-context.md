## 1. Камни и украшения 

Даны две строки строчных латинских символов: строка J и строка S. Символы, входящие в строку J, — «драгоценности», входящие в строку S — «камни». Нужно определить, какое количество символов из S одновременно являются «драгоценностями». Проще говоря, нужно проверить, какое количество символов из S входит в J.
Это разминочная задача, к которой мы размещаем готовые решения. Она очень простая и нужна для того, чтобы вы могли познакомиться с нашей автоматической системой проверки решений. Ввод и вывод осуществляется через файлы, либо через стандартные потоки ввода-вывода, как вам удобнее.

```js
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin
});

let lines = [];
rl.on('line', (line) => {
        lines.push(line);
}).on('close', () => {
    const [jewels, stones] = lines
    let result = 0;
    for (let i = 0; i < stones.length; i++) {
        if (jewels.includes(stones.charAt(i))) {
            ++result;
        }
    }
    process.stdout.write(result.toString());
});
```

## 2. Последовательно идущие единицы 

Требуется найти в бинарном векторе самую длинную последовательность единиц и вывести её длину.

Желательно получить решение, работающее за линейное время и при этом проходящее по входному массиву только один раз.

**Формат ввода**
Первая строка входного файла содержит одно число n, n ≤ 10000. Каждая из следующих n строк содержит ровно одно число — очередной элемент массива.

**Формат вывода**
Выходной файл должен содержать единственное число — длину самой длинной последовательности единиц во входном массиве.

Для решения задачи по нахождению самой длинной последовательности единиц в бинарном векторе за линейное время, мы можем использовать один проход по массиву. В этом решении мы будем отслеживать текущую длину последовательности единиц и максимальную длину, найденную за время выполнения.

### Алгоритм

1. Инициализируем переменные для текущей длины последовательности единиц и максимальной длины.
2. Проходим по каждому элементу массива:
    - Если элемент равен 1, увеличиваем текущую длину.
    - Если элемент равен 0, сравниваем текущую длину с максимальной и сбрасываем текущую длину.
3. В конце цикла необходимо проверить текущую длину еще раз, так как последовательность может закончиться на единице.
4. Выводим максимальную длину.

### Реализация на JavaScript

Вот пример реализации этого алгоритма:
```js
function longestSequenceOfOnes(input) {
let maxLength = 0; // Максимальная длина последовательности
let currentLength = 0; // Текущая длина последовательности

    for (let i = 0; i < input.length; i++) {
        if (input[i] === 1) {
            currentLength++; // Увеличиваем текущую длину
        } else {
            // Сравниваем текущую с максимальной и сбрасываем текущую
            if (currentLength > maxLength) {
                maxLength = currentLength;
            }
            currentLength = 0; // Сбрасываем текущую длину
        }
    }

    // Проверяем в конце, если последняя последовательность была самой длинной
    if (currentLength > maxLength) {
        maxLength = currentLength;
    }

    return maxLength; // Возвращаем максимальную длину
}

const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin
});

let lines = [];
rl.on('line', (line) => {
    lines.push(line);
}).on('close', () => {
    // Пример использования
    const n = lines.shift(); // Количество элементов
    const input = lines.map((item) => +item); // Пример входного массива

    const result = longestSequenceOfOnes(input);
    process.stdout.write(result.toString());
});

```

### Объяснение кода:

1. Инициализация переменных:
    - maxLength — максимальная длина последовательности единиц.
    - currentLength — текущая длина последовательности единиц.

2. Цикл по массиву:
    - Если текущий элемент равен 1, увеличиваем currentLength.
    - Если элемент равен 0, сравниваем currentLength с maxLength и сбрасываем currentLength.

3. Проверка в конце:
    - После завершения цикла проверяем, не была ли последняя последовательность единиц самой длинной.

4. Возврат результата:
    - Функция возвращает максимальную длину последовательности единиц.

### Сложность

- Временная сложность: O(n) — проходим по массиву один раз.
- Пространственная сложность: O(1) — используем фиксированное количество переменных.


## 3. Удаление дубликатов

**Legend**
Дан упорядоченный по неубыванию массив целых 32-разрядных чисел. Требуется удалить из него все повторения.

Желательно получить решение, которое не считывает входной файл целиком в память, т.е., использует лишь константный объем памяти в процессе работы.

**Input format**
Первая строка входного файла содержит единственное число n, n ≤ 1000000.

На следующих n строк расположены числа — элементы массива, по одному на строку. Числа отсортированы по неубыванию.

**Output format**
Выходной файл должен содержать следующие в порядке возрастания уникальные элементы входного массива.

Для решения задачи по удалению повторяющихся элементов из упорядоченного массива целых чисел, можно использовать два указателя. Поскольку массив уже отсортирован, мы можем пройти по нему один раз и сохранить только уникальные элементы.

Для решения задачи по удалению дубликатов из упорядоченного массива целых чисел, используя только константный объем памяти и не загружая весь массив в память, мы можем обрабатывать входные данные по одной строке за раз. Поскольку массив уже отсортирован, мы можем просто сравнивать текущий элемент с предыдущим и записывать только уникальные значения.

Вот исправленный код:
```js
const readline = require('readline');

const rl = readline.createInterface({
input: process.stdin
});
let firstValue = null;
let previousValue = null; // Переменная для хранения предыдущего значения

rl.on('line', (line) => {
    if (firstValue) {
        const currentValue = +line; // Преобразуем строку в число
        // Если это первое значение или текущее значение отличается от предыдущего
        if (previousValue === null || currentValue !== previousValue) {
            process.stdout.write(currentValue + '\n') // Выводим уникальное значение
            previousValue = currentValue; // Обновляем предыдущее значение
        }
    } else {
        firstValue = +line
    }
});
```

### Объяснение кода:

1. Импортирование модуля readline:
    - Мы используем модуль readline для считывания строк из стандартного ввода.

2. Создание интерфейса readline:
    - Создаем интерфейс для чтения данных из стандартного ввода.

3. Переменная previousValue:
    - Инициализируем переменную previousValue, которая будет хранить последнее уникальное значение, чтобы сравнивать его с текущим значением.

4. Обработка строк:
    - В обработчике события line мы считываем каждую строку, преобразуем ее в число и сохраняем в currentValue.
    - Если previousValue равно null (это первое значение) или currentValue отличается от previousValue, мы выводим currentValue и обновляем previousValue.

### Примечания

- Этот код работает в линейное время O(n), так как мы проходим по каждой строке один раз и сравниваем только с одним значением (предыдущим).
- Память используется константно, так как мы не сохраняем все значения в массиве, а только текущее и предыдущее.

### Заключение

Этот подход эффективно удаляет дубликаты из упорядоченного массива целых чисел, не загружая весь массив в память. Если у вас есть дополнительные вопросы или хотите рассмотреть другую задачу, дайте знать!
## 4. Генерация скобочных последовательностей

Дано целое число n. Требуется вывести все правильные скобочные последовательности длины 2 ⋅ n, упорядоченные лексикографически (см. https://ru.wikipedia.org/wiki/Лексикографический_порядок).

В задаче используются только круглые скобки.

Желательно получить решение, которое работает за время, пропорциональное общему количеству правильных скобочных последовательностей в ответе, и при этом использует объём памяти, пропорциональный n.

**Формат ввода**
Единственная строка входного файла содержит целое число n, 0 ≤ n ≤ 11

**Формат вывода**
Выходной файл содержит сгенерированные правильные скобочные последовательности, упорядоченные лексикографически.

Для решения задачи по генерации всех правильных скобочных последовательностей длины 2 * n, мы можем использовать рекурсивный подход с отслеживанием количества открывающихся и закрывающихся скобок.

### Алгоритм

1. Рекурсия: Создаем рекурсивную функцию, которая будет строить последовательности, добавляя открывающиеся и закрывающиеся скобки.
2. Условия:
    - Мы можем добавить открывающую скобку (, если количество открывающихся скобок меньше n.
    - Мы можем добавить закрывающую скобку ), если количество закрывающихся скобок меньше количества открывающихся.
3. Базовый случай: Когда длина текущей последовательности достигает 2 * n, мы сохраняем последовательность.
4. Лексикографический порядок: Поскольку мы сначала добавляем ( и затем ), последовательности будут автоматически упорядочены в лексикографическом порядке.

### Реализация на JavaScript

Вот пример реализации этого алгоритма:
```js
function generateParentheses(n) {
const result = [];

    function backtrack(current, open, close) {
        // Если длина текущей последовательности равна 2 * n
        if (current.length === 2 * n) {
            result.push(current);
            process.stdout.write(current + '\n')
            return;
        }

        // Добавляем открывающую скобку, если это возможно
        if (open < n) {
            backtrack(current + '(', open + 1, close);
        }

        // Добавляем закрывающую скобку, если это возможно
        if (close < open) {
            backtrack(current + ')', open, close + 1);
        }
    }

    // Запускаем рекурсию с пустой строкой и нулевыми счетчиками
    backtrack('', 0, 0);
    return result;
}

// Пример использования
const readline = require('readline');

const rl = readline.createInterface({
   input: process.stdin
});

rl.on('line', (line) => {
   const currentValue = +line; // Преобразуем строку в число
   const sequences = generateParentheses(currentValue);
});
```
второй вариант без рекурсии 
```js
function generateParentheses(n) {
    const result = [];
    const stack = [{ current: '', open: 0, close: 0 }]; // Инициализируем стек с начальным состоянием

    while (stack.length > 0) {
        const { current, open, close } = stack.pop(); // Извлекаем текущее состояние из стека

        // Если длина текущей последовательности равна 2 * n, добавляем в результат
        if (current.length === 2 * n) {
            result.push(current);
            process.stdout.write(current + '\n'); // Выводим последовательность
            continue; // Переходим к следующему состоянию в стеке
        }

        // Добавляем открывающую скобку, если это возможно
        if (open < n) {
            stack.push({ current: current + '(', open: open + 1, close });
        }

        // Добавляем закрывающую скобку, если это возможно
        if (close < open) {
            stack.push({ current: current + ')', open, close: close + 1 });
        }
    }

    return result;
}

// Пример использования
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin
});

rl.on('line', (line) => {
    const currentValue = +line; // Преобразуем строку в число
   const sequences = generateParentheses(currentValue); // Генерируем последовательности
   // sequences.forEach(seq => process.stdout.write(seq + '\n')); // Выводим последовательности
});
```

### Объяснение кода:

1. Функция generateParentheses:
    - Инициализирует массив result для хранения всех правильных скобочных последовательностей.
    - Запускает рекурсивную функцию backtrack.

2. Функция backtrack:
    - Принимает текущую последовательность current, количество открывающихся open и закрывающихся close скобок.
    - Если длина текущей последовательности достигает 2 * n, добавляем ее в result.
    - Проверяем возможность добавления открывающей и закрывающей скобки и вызываем backtrack рекурсивно.

3. Вывод результата:
    - После генерации последовательностей, они выводятся в консоль.

### Сложность

- Временная сложность: O(4^n / √n) — это количество правильных скобочных последовательностей.
- Пространственная сложность: O(n) — используется стек вызовов рекурсии и память для хранения последовательностей.

## 5. Анаграммы

Даны две строки, состоящие из строчных латинских букв. Требуется определить, являются ли эти строки анаграммами, т. е. отличаются ли они только порядком следования символов.

**Формат ввода**
Входной файл содержит две строки строчных латинских символов, каждая не длиннее 100 000 символов. Строки разделяются символом перевода строки.

**Формат вывода**
Выходной файл должен содержать единицу, если строки являются анаграммами, и ноль в противном случае.

Для определения, являются ли две строки анаграммами, можно использовать несколько подходов. Один из наиболее эффективных способов — это использование хэш-таблицы (или объекта в JavaScript) для подсчета количества каждого символа в обеих строках и сравнение этих подсчетов.

### Алгоритм

1. Если длины строк не равны, они не могут быть анаграммами.
2. Создаем объект для хранения количества каждого символа из первой строки.
3. Проходим по первой строке и увеличиваем счетчик для каждого символа.
4. Проходим по второй строке и уменьшаем счетчик для каждого символа.
5. Если в конце все счетчики равны нулю, строки являются анаграммами.

### Реализация на JavaScript

Вот пример реализации этого алгоритма:
```js
function areAnagrams(str1, str2) {
// Если длины строк не равны, они не могут быть анаграммами
if (str1.length !== str2.length) {
return 0;
}

    const charCount = {};

    // Подсчитываем символы в первой строке
    for (let char of str1) {
        charCount[char] = (charCount[char] || 0) + 1;
    }

    // Уменьшаем счетчики для символов во второй строке
    for (let char of str2) {
        if (!charCount[char]) {
            return 0; // Если символ отсутствует, строки не анаграммы
        }
        charCount[char]--;
    }

    // Проверяем, все ли счетчики равны нулю
    for (let count of Object.values(charCount)) {
        if (count !== 0) {
            return 0; // Если есть ненулевые счетчики, строки не анаграммы
        }
    }

    return 1; // Строки являются анаграммами
}

// Пример использования
const str1 = "listen";
const str2 = "silent";
const result = areAnagrams(str1, str2);
console.log(result); // Вывод: 1
```

### Объяснение кода:

1. Проверка длины:
    - Если длины строк не равны, сразу возвращаем 0.

2. Подсчет символов:
    - Используем объект charCount для хранения количества каждого символа из первой строки.

3. Уменьшение счетчиков:
    - Проходим по второй строке, уменьшая счетчики в charCount. Если встречаем символ, который отсутствует в charCount, возвращаем 0.

4. Проверка счетчиков:
    - В конце проверяем, все ли счетчики равны нулю. Если нет, возвращаем 0.

5. Возврат результата:
    - Если все проверки пройдены, возвращаем 1, что означает, что строки являются анаграммами.

### Сложность

- Временная сложность: O(n) — проходим по каждой строке один раз.
- Пространственная сложность: O(1) — используем фиксированное количество памяти для хранения символов (всего 26 строчных латинских букв).

## 6. Интересное путешествие

Не секрет, что некоторые программисты очень любят путешествовать. Хорошо всем известный программист Петя тоже очень любит путешествовать, посещать музеи и осматривать достопримечательности других городов.
Для перемещений между из города в город он предпочитает использовать машину. При этом он заправляется только на станциях в городах, но не на станциях по пути. Поэтому он очень аккуратно выбирает маршруты, чтобы машина не заглохла в дороге. А ещё Петя очень важный член команды, поэтому он не может себе позволить путешествовать слишком долго. Он решил написать программу, которая поможет ему с выбором очередного путешествия. Но так как сейчас у него слишком много других задач, он попросил вас помочь ему.

Расстояние между двумя городами считается как сумма модулей разности по каждой из координат. Дороги есть между всеми парами городов.

**Формат ввода**
В первой строке входных данных записано количество городов
**n** `(2 ≤ n ≤ 1000)`. 
В следующих **n**
строках даны два целых числа: координаты каждого города, не превосходящие по модулю миллиарда. Все города пронумерованы числами от 1 до
**n** в порядке записи во входных данных.
В следующей строке записано целое положительное число
**k** , не превосходящее двух миллиардов, — максимальное расстояние между городами, которое Петя может преодолеть без дозаправки машины.

В последней строке записаны два различных числа — номер города, откуда едет Петя, и номер города, куда он едет.

**Формат вывода**
Если существуют пути, удовлетворяющие описанным выше условиям, то выведите минимальное количество дорог, которое нужно проехать, чтобы попасть из начальной точки маршрута в конечную. Если пути не существует, выведите -1.


Для решения задачи о нахождении минимального количества дорог, которые нужно проехать, чтобы добраться из одного города в другой, мы можем использовать алгоритм поиска в ширину (BFS). Этот алгоритм подходит, так как мы ищем кратчайший путь в невзвешенном графе, где каждое ребро (дорога между городами) имеет одинаковую "стоимость".

### Алгоритм

1. Считывание данных: Считываем количество городов и их координаты, а также максимальное расстояние, которое Петя может проехать без дозаправки.
2. Построение графа: Создаем граф, где города являются узлами, а дороги — ребрами. Дорога между двумя городами существует, если расстояние между ними не превышает k.
3. Поиск в ширину (BFS): Используем BFS для нахождения кратчайшего пути от начального города к конечному. Если мы достигли конечного города, возвращаем количество пройденных дорог. Если нет, возвращаем -1.

### Реализация на JavaScript

Вот пример реализации этого алгоритма:
```js
function manhattanDistance(city1, city2) {
return Math.abs(city1[0] - city2[0]) + Math.abs(city1[1] - city2[1]);
}

function bfs(start, end, graph) {
const queue = [start];
const visited = new Set();
visited.add(start);
let distance = 0;

    while (queue.length > 0) {
        const size = queue.length;
        for (let i = 0; i < size; i++) {
            const current = queue.shift();
            if (current === end) {
                return distance; // Возвращаем количество пройденных дорог
            }

            for (const neighbor of graph[current]) {
                if (!visited.has(neighbor)) {
                    visited.add(neighbor);
                    queue.push(neighbor);
                }
            }
        }
        distance++;
    }

    return -1; // Если путь не найден
}

function findShortestPath(n, cities, k, startCity, endCity) {
// Построение графа
const graph = Array.from({ length: n }, () => []);

    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            if (manhattanDistance(cities[i], cities[j]) <= k) {
                graph[i].push(j);
                graph[j].push(i);
            }
        }
    }

    // Поиск в ширину
    return bfs(startCity - 1, endCity - 1, graph);
}

// Пример использования
const n = 5; // Количество городов
const cities = [
[0, 0],
[1, 1],
[2, 2],
[3, 3],
[10, 10]
]; // Координаты городов
const k = 5; // Максимальное расстояние
const startCity = 1; // Начальный город
const endCity = 4; // Конечный город

const result = findShortestPath(n, cities, k, startCity, endCity);
console.log(result); // Вывод: количество дорог или -1

```
### Объяснение кода:

1. Функция manhattanDistance: Вычисляет манхэттенское расстояние между двумя городами.
2. Функция bfs: Выполняет поиск в ширину, чтобы найти кратчайший путь от стартового города до конечного.
3. Функция findShortestPath:
    - Строит граф, добавляя ребра между городами, если расстояние между ними меньше или равно k.
    - Вызывает функцию bfs для нахождения кратчайшего пути.

### Сложность

- Временная сложность: O(n^2) — из-за двойного цикла для построения графа.
- Пространственная сложность: O(n) — для хранения графа и очереди BFS.
